#!/usr/bin/env python2
"""
SecureDrop Admin Toolkit.

For use by administrators to install, maintain, and manage their SD
instances.
"""

import argparse
import logging
import os
import re
import string
import subprocess
import sys
import types
import prompt_toolkit
from prompt_toolkit.validation import Validator, ValidationError

sdlog = logging.getLogger(__name__)

SD_DIR = os.path.realpath(os.path.join(os.path.dirname(__file__), '..'))
ANSIBLE_PATH = os.path.join(SD_DIR, "./install_files/ansible-base")
SITE_CONFIG = os.path.join(ANSIBLE_PATH, "group_vars/all/site-specific")
VENV_DIR = os.path.join(SD_DIR, ".venv")
VENV_ACTIVATION = os.path.join(VENV_DIR, 'bin/activate_this.py')


class SiteConfig(object):

    class ValidateUser(Validator):
        def validate(self, document):
            text = document.text
            if text != '' and text != 'root' and text != 'amnesia':
                return True
            raise ValidationError(
                message="Must not be root, amnesia or an empty string")

    class ValidateIP(Validator):
        def validate(self, document):
            if re.match('((25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(\.|$)){4}$',
                        document.text):
                return True
            raise ValidationError(
                message="An IP address must be something like 10.240.20.83")

    class ValidateDNS(Validator):
        def validate(self):
            raise Exception()  # pragma: no cover

        def is_tails(self):
            try:
                id = subprocess.check_output('lsb_release --id --short',
                                             shell=True).strip()
            except subprocess.CalledProcessError:
                id = None
            return id == 'Tails'

        def lookup_fqdn(self, fqdn, dns=None):
            cmd = 'host -W=10 -T -4 ' + fqdn
            if self.is_tails():
                cmd = 'torify ' + cmd
            cmd += ' ' + (dns and dns or '8.8.8.8')
            try:
                result = subprocess.check_output(cmd, shell=True,
                                                 stderr=subprocess.STDOUT)
            except subprocess.CalledProcessError as e:
                result = e.output
            sdlog.debug(cmd + ' => ' + result)
            return 'has address' in result

    class ValidateDNSServer(ValidateDNS):
        def validate(self, document):
            if self.lookup_fqdn('gnu.org', document.text):
                return True
            raise ValidationError(
                message='Unable to resolve gnu.org using this DNS')

    class ValidateFQDN(ValidateDNS):
        def validate(self, document):
            if self.lookup_fqdn(document.text):
                return True
            raise ValidationError(
                message='Unable to resolve ' + document.text)

    class ValidatePath(Validator):
        def __init__(self, basedir):
            self.basedir = basedir
            super(SiteConfig.ValidatePath, self).__init__()

        def validate(self, document):
            if document.text == '':
                raise ValidationError(
                    message='an existing file name is required')
            path = os.path.join(self.basedir, document.text)
            if os.path.exists(path):
                return True
            raise ValidationError(
                message=path + ' file does not exist')

    class ValidateYesNo(Validator):
        def validate(self, document):
            text = document.text.lower()
            if text == 'yes' or text == 'no':
                return True
            raise ValidationError(message="Must be either yes or no")

    class ValidateFingerprint(Validator):
        def validate(self, document):
            text = document.text.replace(' ', '')
            if text == '65A1B5FF195B56353CC63DFFCC40EF1228271441':
                raise ValidationError(
                    message='This is the TEST journalist fingerprint')
            if text == '600BC6D5142C68F35DDBCEA87B597104EDDDC102':
                raise ValidationError(
                    message='This is the TEST admin fingerprint')
            if not re.match('[a-fA-F0-9]{40}$', text):
                raise ValidationError(
                    message='fingerprints must be 40 hexadecimal characters')
            return True

    class ValidateInt(Validator):
        def validate(self, document):
            if re.match('\d+$', document.text):
                return True
            raise ValidationError(message="Must be an integer")

    class ValidateOSSECEmail(Validator):
        def validate(self, document):
            text = document.text
            if text and '@' in text and 'ossec@ossec.test' != text:
                return True
            raise ValidationError(
                message=("Must contain a @ and be set to "
                         "something other than ossec@ossec.test"))

    def __init__(self, args):
        self.args = args
        translations = SiteConfig.Locales(
            self.args.app_path).get_translations()
        translations = " ".join(translations)
        self.desc = [
            ['ssh_users', 'sd',
             u'Username for SSH access to the servers',
             SiteConfig.ValidateUser(),
             None],
            ['app_ip', '10.20.2.2',
             u'Local IPv4 address for the Application Server',
             SiteConfig.ValidateIP(),
             None],
            ['monitor_ip', '10.20.3.2',
             u'Local IPv4 address for the Monitor Server',
             SiteConfig.ValidateIP(),
             None],
            ['app_hostname', 'app',
             u'Hostname for Application Server',
             None,
             None],
            ['monitor_hostname', 'mon',
             u'Hostname for Monitor Server',
             None,
             None],
            ['dns_server', '8.8.8.8',
             u'DNS server specified during installation',
             SiteConfig.ValidateDNSServer(),
             None],
            ['securedrop_app_https_on_source_interface', 'no',
             u'Whether HTTPS should be enabled on '
             'Source Interface (requires EV cert)',
             SiteConfig.ValidateYesNo(),
             lambda x: x.lower() == 'yes'],
            ['securedrop_app_gpg_public_key', 'SecureDrop.asc',
             u'Local filepath to public key for '
             'SecureDrop Application GPG public key',
             SiteConfig.ValidatePath(self.args.ansible_path),
             None],
            ['securedrop_app_gpg_fingerprint', '',
             u'Full fingerprint for the SecureDrop Application GPG Key',
             SiteConfig.ValidateFingerprint(),
             self.sanitize_fingerprint],
            ['ossec_alert_gpg_public_key', 'ossec.pub',
             u'Local filepath to OSSEC alerts GPG public key',
             SiteConfig.ValidatePath(self.args.ansible_path),
             None],
            ['ossec_gpg_fpr', '',
             u'Full fingerprint for the OSSEC alerts GPG public key',
             SiteConfig.ValidateFingerprint(),
             self.sanitize_fingerprint],
            ['ossec_alert_email', '',
             u'Admin email address for receiving OSSEC alerts',
             SiteConfig.ValidateOSSECEmail(),
             None],
            ['smtp_relay', "smtp.gmail.com",
             u'SMTP relay for sending OSSEC alerts',
             SiteConfig.ValidateFQDN(),
             None],
            ['smtp_relay_port', '587',
             u'SMTP port for sending OSSEC alerts',
             SiteConfig.ValidateInt(),
             int],
            ['sasl_domain', "gmail.com",
             u'SASL domain for sending OSSEC alerts',
             SiteConfig.ValidateFQDN(),
             None],
        ]

    def load_and_update_config(self):
        if self.exists():
            self.config = self.load()
        else:
            self.config = None
        return self.update_config()

    def update_config(self):
        config = {}
        for (var, default, prompt, validator, transform) in self.desc:
            if self.config:
                default = self.config.get(var)
            prompt += ': '
            sdlog.debug(prompt + str(default))
            config[var] = self.validated_input(
                prompt, default, validator, transform)
        self.config = config
        self.save()
        self.validate_gpg_keys()
        return True

    def validated_input(self, prompt, default, validator, transform):
        if type(default) is bool:
            default = default and 'yes' or 'no'
        if type(default) is int:
            default = str(default)
        if isinstance(default, types.ListType):
            default = " ".join(default)
        kwargs = {}
        if validator:
            kwargs['validator'] = validator
        value = prompt_toolkit.prompt(prompt,
                                      default=unicode(default, 'utf-8'),
                                      **kwargs)
        if transform:
            return transform(value)
        else:
            return value

    def sanitize_fingerprint(self, value):
        return value.upper().replace(' ', '')

    def exists(self):
        return os.path.exists(self.args.site_config)

    def save(self):
        # Yaml library cannot be imported until virtualenv is activated
        # (hence the yaml library is not imported up-top)
        import yaml

        with open(self.args.site_config, 'w') as site_config_file:
            yaml.safe_dump(self.config,
                           site_config_file,
                           default_flow_style=False)

    def load(self):
        # Yaml library cannot be imported until virtualenv is activated
        # (hence the yaml library is not imported up-top)
        import yaml

        try:
            with open(self.args.site_config) as site_config_file:
                return yaml.safe_load(site_config_file)
        except IOError:
            sdlog.error("Config file missing, re-run with sdconfig")
            raise
        except yaml.YAMLError:
            sdlog.error("There was an issue processing {}".format(
                self.args.site_config))
            raise


def setup_logger(verbose=False):
    """ Configure logging handler """
    # Set default level on parent
    sdlog.setLevel(logging.DEBUG)
    level = logging.DEBUG if verbose else logging.INFO

    stdout = logging.StreamHandler(sys.stdout)
    stdout.setFormatter(logging.Formatter('%(levelname)s: %(message)s'))
    stdout.setLevel(level)
    sdlog.addHandler(stdout)


def activate_venv(args):
    """Use to activate the local virtualenv"""
    try:
        # If developer mode enabled, no need to enable virtualenv
        if not args.d:
            execfile(VENV_ACTIVATION, dict(__file__=VENV_ACTIVATION))
    except IOError:
        sdlog.error("Pre-requisites not in place, re-run command with 'setup'")
        raise


def sdconfig(args):
    """Configure SD site settings"""
    activate_venv(args)
    SiteConfig(args).load_and_update_config()


def run_command(command):
    """
    Wrapper function to display stdout for running command,
    similar to how shelling out in a Bash script displays rolling output.

    Yields a list of the stdout from the `command`, and raises a
    CalledProcessError if `command` returns non-zero.
    """
    popen = subprocess.Popen(command,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.STDOUT)
    for stdout_line in iter(popen.stdout.readline, ""):
        yield stdout_line
    popen.stdout.close()
    return_code = popen.wait()
    if return_code:
        raise subprocess.CalledProcessError(return_code, command)


def install_apt_dependencies(args):
    """
    Install apt dependencies in Tails. In order to install Ansible in
    a virtualenv, first there are a number of Python prerequisites.
    """
    sdlog.info("Installing SecureDrop Admin dependencies")
    sdlog.info(("You'll be prompted for the temporary Tails admin password,"
                " which was set on Tails login screen"))

    apt_command = ['sudo', 'su', '-c',
                   "apt-get update && \
                   apt-get -q -o=Dpkg::Use-Pty=0 install -y \
                   python-virtualenv \
                   python-pip \
                   ccontrol \
                   virtualenv \
                   libffi-dev \
                   libssl-dev \
                   libpython2.7-dev",
                   ]

    try:
        # Print command results in real-time, to keep Admin apprised
        # of progress during long-running command.
        for output_line in run_command(apt_command):
            print(output_line.rstrip())
    except subprocess.CalledProcessError:
        # Tails supports apt persistence, which was used by SecureDrop
        # under Tails 2.x. If updates are being applied, don't try to pile
        # on with more apt requests.
        sdlog.error(("Failed to install apt dependencies. Check network"
                     " connection and try again."))
        raise


def envsetup(args):
    """Installs Admin tooling required for managing SecureDrop. Specifically:

        * updates apt-cache
        * installs apt packages for Python virtualenv
        * creates virtualenv
        * installs pip packages inside virtualenv

    The virtualenv is created within the Persistence volume in Tails, so that
    Ansible is available to the Admin on subsequent boots without requiring
    installation of packages again.
    """
    # virtualenv doesnt exist? Install dependencies and create
    if not os.path.exists(VENV_ACTIVATION):

        install_apt_dependencies(args)

        # Technically you can create a virtualenv from within python
        # but pip can only be run over tor on tails, and debugging that
        # along with instaling a third-party dependency is not worth
        # the effort here.
        sdlog.info("Setting up virtualenv")
        try:
            sdlog.debug(subprocess.check_output(['torify', 'virtualenv',
                                                 VENV_DIR],
                                                stderr=subprocess.STDOUT))
        except subprocess.CalledProcessError as e:
            sdlog.debug(e.output)
            sdlog.error(("Unable to create virtualenv. Check network settings"
                         " and try again."))
            raise
    else:
        sdlog.info("Virtualenv already exists, not creating")

    install_pip_dependencies(args)

    sdlog.info("Finished installing SecureDrop dependencies")


def install_pip_dependencies(args, pip_install_cmd=[
        'torify',
        os.path.join(VENV_DIR, 'bin', 'pip'),
        'install',
        # Specify requirements file.
        '-r', os.path.join(SD_DIR, 'securedrop',
                           'requirements', 'admin-requirements.txt'),
        '--require-hashes',
        # Make sure to upgrade packages only if necessary.
        '-U', '--upgrade-strategy', 'only-if-needed',
]):
    """
    Install Python dependencies via pip into virtualenv.
    """

    sdlog.info("Checking Python dependencies for securedrop-admin")
    try:
        pip_output = subprocess.check_output(pip_install_cmd,
                                             stderr=subprocess.STDOUT)
    except subprocess.CalledProcessError as e:
        sdlog.debug(e.output)
        sdlog.error(("Failed to install pip dependencies. Check network"
                     " connection and try again."))
        raise

    sdlog.debug(pip_output)
    if "Successfully installed" in pip_output:
        sdlog.info("Python dependencies for securedrop-admin upgraded")
    else:
        sdlog.info("Python dependencies for securedrop-admin are up-to-date")


def install_securedrop(args):
    """Install/Update SecureDrop"""
    activate_venv(args)
    SiteConfig(args).load()

    sdlog.info("Now installing SecureDrop on remote servers.")
    sdlog.info("You will be prompted for the sudo password on the "
               "servers.")
    sdlog.info("The sudo password is only necessary during initial "
               "installation.")
    subprocess.check_call([os.path.join(ANSIBLE_PATH,
                                        'securedrop-prod.yml'),
                          '--ask-become-pass'], cwd=ANSIBLE_PATH)


def backup_securedrop(args):
    """Perform backup of the SecureDrop Application Server.
    Creates a tarball of submissions and server config, and fetches
    back to the Admin Workstation. Future `restore` actions can be performed
    with the backup tarball."""
    activate_venv(args)
    sdlog.info("Backing up the SecureDrop Application Server")
    ansible_cmd = [
        'ansible-playbook',
        os.path.join(ANSIBLE_PATH, 'securedrop-backup.yml'),
    ]
    subprocess.check_call(ansible_cmd, cwd=ANSIBLE_PATH)


def restore_securedrop(args):
    """Perform restore of the SecureDrop Application Server.
    Requires a tarball of submissions and server config, created via
    the `backup` action."""
    activate_venv(args)
    sdlog.info("Restoring the SecureDrop Application Server from backup")
    # Canonicalize filepath to backup tarball, so Ansible sees only the
    # basename. The files must live in ANSIBLE_PATH, but the securedrop-admin
    # script will be invoked from the repo root, so preceding dirs are likely.
    restore_file_basename = os.path.basename(args.restore_file)
    ansible_cmd = [
        'ansible-playbook',
        os.path.join(ANSIBLE_PATH, 'securedrop-restore.yml'),
        '-e',
        "restore_file='{}'".format(restore_file_basename),
    ]
    subprocess.check_call(ansible_cmd, cwd=ANSIBLE_PATH)


def run_tails_config(args):
    """Configure Tails environment post SD install"""
    activate_venv(args)
    sdlog.info("Configuring Tails workstation environment")
    sdlog.info(("You'll be prompted for the temporary Tails admin password,"
                " which was set on Tails login screen"))
    ansible_cmd = [
        os.path.join(ANSIBLE_PATH, 'securedrop-tails.yml'),
        "--ask-become-pass",
        # Passing an empty inventory file to override the automatic dynamic
        # inventory script, which fails if no site vars are configured.
        '-i', '/dev/null',
    ]
    subprocess.check_call(ansible_cmd,
                          cwd=ANSIBLE_PATH)


def get_logs(args):
    """Get logs for forensics and debugging purposes"""
    activate_venv(args)
    sdlog.info("Gathering logs for forensics and debugging")
    ansible_cmd = [
        'ansible-playbook',
        os.path.join(ANSIBLE_PATH, 'securedrop-logs.yml'),
    ]
    subprocess.check_call(ansible_cmd, cwd=ANSIBLE_PATH)
    sdlog.info("Encrypt logs and send to securedrop@freedom.press or upload "
               "to the SecureDrop support portal.")


def parse_argv(argv):
    class ArgParseFormatterCombo(argparse.ArgumentDefaultsHelpFormatter,
                                 argparse.RawTextHelpFormatter):
        """Needed to combine formatting classes for help output"""
        pass

    parser = argparse.ArgumentParser(description=__doc__,
                                     formatter_class=ArgParseFormatterCombo)
    parser.add_argument('-v', action='store_true', default=False,
                        help="Increase verbosity on output")
    parser.add_argument('-d', action='store_true', default=False,
                        help="Developer mode. Not to be used in production.")
    parser.add_argument('--site-config', default=SITE_CONFIG,
                        help="path to the YAML site configuration file")
    parser.add_argument('--ansible-path', default=ANSIBLE_PATH,
                        help="path to the Ansible root")
    parser.add_argument('--app-path', default=APP_PATH,
                        help="path to the SecureDrop application root")
    subparsers = parser.add_subparsers()

    parse_setup = subparsers.add_parser('setup', help=envsetup.__doc__)
    parse_setup.set_defaults(func=envsetup)

    parse_sdconfig = subparsers.add_parser('sdconfig', help=sdconfig.__doc__)
    parse_sdconfig.set_defaults(func=sdconfig)

    parse_install = subparsers.add_parser('install',
                                          help=install_securedrop.__doc__)
    parse_install.set_defaults(func=install_securedrop)

    parse_tailsconfig = subparsers.add_parser('tailsconfig',
                                              help=run_tails_config.__doc__)
    parse_tailsconfig.set_defaults(func=run_tails_config)

    parse_backup = subparsers.add_parser('backup',
                                         help=backup_securedrop.__doc__)
    parse_backup.set_defaults(func=backup_securedrop)

    parse_restore = subparsers.add_parser('restore',
                                          help=restore_securedrop.__doc__)
    parse_restore.set_defaults(func=restore_securedrop)
    parse_restore.add_argument("restore_file")

    parse_logs = subparsers.add_parser('logs',
                                       help=get_logs.__doc__)
    parse_logs.set_defaults(func=get_logs)

    return parser.parse_args(argv)


if __name__ == "__main__":
    args = parse_argv(sys.argv[1:])
    setup_logger(args.v)
    if args.v:
        args.func(args)
    else:
        try:
            args.func(args)
        except Exception:
            sys.exit(1)
        else:
            sys.exit(0)
